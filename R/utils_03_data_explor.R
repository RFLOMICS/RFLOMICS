### ============================================================================
### [03_data_processing] function and internal function
### ----------------------------------------------------------------------------
# N. Bessoltane
# D. Charif
# A. Hulot

######## INTERNAL - Transform the Data ###########

# .applyTransformation: apply the transformation method stored in object@metadata[["transform_method"]] and modify the assay.
#' @title apply_transformation
#'
#' @param object An object of class \link{RflomicsSE}
#' @keywords internal
#' @noRd
#'

.applyTransformation <- function(object) {
  
  if (is.null(getTransSettings(object)$method)) {
    warning("Expect transformation method.")
    return(object)
  }
  
  if (.isTransformed(object)) {
    warning("Data were already transformed before!")
    return(object)
  }
  
  transformation.res <- getAnalysis(object,
                                    name = "DataProcessing", 
                                    subName = "Transformation")
  
  transform_method <- getTransSettings(object)$method
  assayTransform <- assay(object, withDimnames = TRUE)
  validTransform <- TRUE
  
  
  switch(transform_method,
         "log1p" = {
           assay(object) <- log1p(assayTransform)
         },
         "log2" = {
           assay(object) <- log2(assayTransform + 10^-10)
         },
         "log10" = {
           assay(object) <- log10(assayTransform + 10^-10)
         },
         "squareroot" = {
           assay(object) <- sqrt(assayTransform)
         },
         "none" = {
           assay(object) <- assayTransform
         },
         {
           assay(object) <- assayTransform
           message("Could not recognize the transformation method. No transformation applied. Please check your parameters.")
           validTransform <- FALSE
         } # default is none
  )
  
  if (transform_method != "none" && validTransform)
    transformation.res[["transformed"]] <- TRUE
  
  object <- setElementToMetadata(object, 
                                 name = "DataProcessing", 
                                 subName = "Transformation", 
                                 content = transformation.res)
  
  return(object)
}

######## INTERNAL - Normalize the Data ###########

# .applyNorm: apply the normalization method stored in object@metadata[["Normalization"]] and modify the assay.
#' @title .applyNorm
#'
#' @param object An object of class \link{RflomicsSE}
#' @description apply the normalization to the assay. Usually, after the transformation,
#' unless in the case of counts RNASeq data (TMM), where log2 is the second step.
#' @keywords internal
#' @noRd
#'

.applyNorm <- function(object) {
  
  if (is.null(getNormSettings(object)$method)) {
    warning("Expects normalization method.")
    return(object)
  }
  
  if (.isNorm(object)) {
    warning("Data were already normalized before!")
    return(object)
  }
  
  normalization.res <- getAnalysis(object,
                                   name = "DataProcessing", 
                                   subName = "Normalization")
  
  norm_method <- getNormSettings(object)$method
  coefNorm <- getCoeffNorm(object)
  validNorm <- TRUE
  
  assayTransform <- assay(object)
  
  switch(norm_method,
         "median" = {
           assay(object) <- sweep(assayTransform, 2, coefNorm, "-")
         },
         "totalSum" = {
           assay(object) <- sweep(assayTransform, 2, coefNorm, "/")
         },
         "TMM" = {
           scales_factors <- coefNorm$norm.factors * coefNorm$lib.size
           assay(object) <- scale(assayTransform + 1, 
                                  center = FALSE, 
                                  scale = scales_factors)
         },
         "none" = {
           assay(object) <- assayTransform
         },
         { # default is none
           assay(object) <- assayTransform
           message("Could not recognize the normalization method. No normalization applied. Please check your parameters.")
           validNorm <- FALSE
         }
  )
  
  if (norm_method != "none" && validNorm) 
    normalization.res[["normalized"]] <- TRUE
  
  object <- setElementToMetadata(object, 
                                 name = "DataProcessing", 
                                 subName = "Normalization", 
                                 content = normalization.res)
  return(object)
}


######## INTERNAL - Filtred the Data ###########

# .applyFiltering: apply the normalization method stored in object@metadata[["Normalization"]] and modify the assay.
#' @title .applyFiltering
#'
#' @param object An object of class \link{RflomicsSE}
#' @description apply the filtering to the assay. Usually.
#' @keywords internal
#' @noRd
#'

.applyFiltering <- function(object) {
  
  # apply low count filtering
  if(is.null(getFilterSettings(object)$method)){
    return(object)
  }
  
  if (.isFiltered(object)) {
    warning("Data were already filtred before!")
    return(object)
  }
  
  
  filtering.res <- 
    getAnalysis(object, 
                name = "DataProcessing", 
                subName = "featureFiltering")
  
  filteredFeatures <- getFilteredFeatures(object)
  if(!is.null(filteredFeatures)){
    object <- 
      object[setdiff(names(object), filteredFeatures)]
    
    filtering.res[["filtered"]] <- TRUE
  }
  
  object <- setElementToMetadata(object, 
                                 name    = "DataProcessing", 
                                 subName = "featureFiltering", 
                                 content = filtering.res)
  return(object)
}


#' @title .applyLog
#'
#' @param object An object of class \link{RflomicsSE}
#' @param log log type
#' @description apply the log to the assay. Usually.
#' @keywords internal
#' @noRd
#'
.applyLog <- function(object, log = "log2") {
  
  if(getOmicsTypes(object) != "RNAseq")
    return(object)
  
  assay(object) <- 
    switch(log,
           "log2" = {
             if(.isNorm(object))
               log2(assay(object))
             else
               log2(assay(object) + 1)
           }
    )
  
  metadata(object)[["DataProcessing"]][["log"]] <- "log2"
  
  return(object)
}



######## INTERNAL - Check, transform and normalize the data ###########

# checkTransNorm: check the data, transform them and normalize them.
#' @title .checkTransNorm
#'
#' @param object An object of class \link{RflomicsSE}
#' @description apply the normalization and the transformation stored into the metadata of the SE object.
#'  Applies TMM and log2 transformation for RNAseq data.
#' @keywords internal
#' @noRd
#'

.checkTransNorm <- function(object, raw = FALSE) {
  if (!is(object, "RflomicsSE")) stop("Object is not a RflomicsSE")
  
  # check things
  if (.checkNA(object)) stop("NA detected in the assay.")
  
  # No transformation (except for RNAseq, which expect counts...)
  if (raw) {
    if (.isTransformed(object)) warning("Your data are not raw (transformed)")
    if (.isNorm(object)) warning("Your data are not raw (normalized)")
    
    if (getOmicsTypes(object) == "RNAseq") {
      assay(object) <- log2(assay(object) + 1)
    }
  } else {
    # if RNAseq
    switch(getOmicsTypes(object),
           "RNAseq" = {
             # Really depends if TMM is the normalization or not.
             # Make it easier: force TMM and log2.
             if (.isTransformed(object)) 
               stop("Expect untransformed RNAseq data at this point.")
             
             if (.isNorm(object)) {
               switch(getNormSettings(object)$method, 
                      "TMM" = {assay(object) <- log2(assay(object))}, # +1 in the apply_norm function
                      {message("RNAseq counts expects TMM normalization. Data were already normalized with another method.
                Skipping to the end without transforming or normalizing data.")}
               )
             } else {
               # Force "none" transformation.
               if (getTransSettings(object)$method != "none") {
                 message("RNAseq counts expects TMM normalization. Transformation is done after the normalization,
                  using 'none' as transform method. Data will be transformed using log2 after the normalization anyway")
                 
                 object <- setTrans(object, method = "none")
               }
               
               # Force TMM normalization
               if (getNormSettings(object)$method != "TMM") {
                 message("For RNAseq data (counts), only TMM applies for now. Forcing TMM normalization.")
                 object <- runNormalization(object, normMethod = "TMM")
               }
             }
             
             # Finally transforming the data.
             object <- .applyTransformation(object) # none
             object <- .applyNorm(object) # TMM
             assay(object) <- log2(assay(object)) # +1 in the .applyNorm function
             
           }, # end switch rnaseq
           { # default
             # in case any other omics type (does not expect counts)
             # transform and norm
             if (!.isTransformed(object)) object <- .applyTransformation(object)
             if (!.isNorm(object)) object <- .applyNorm(object)
           }
    )
  }
  
  # check things
  if (.checkNA(object)) stop("NA detected in the assay.")
  
  return(object)
}

######## INTERNAL - isNorm, isTransform, getNorm, getTransform ###########

#' @title isNorm, isTransform, getNorm, getTransform, setNorm, setTrans
#'
#' @param object An object of class \link{RflomicsSE}
#' @description get if an assay has been transformed or normalized.
#' @keywords internal
#' @importFrom S4Vectors metadata
#' @importFrom S4Vectors metadata<-
#' @noRd
#'

.isFiltered <- function(object) {
  metadata(object)[["DataProcessing"]][["featureFiltering"]][["filtered"]]
}

.isTransformed <- function(object) {
  metadata(object)[["DataProcessing"]][["Transformation"]][["transformed"]]
}

.isNorm <- function(object) {
  metadata(object)[["DataProcessing"]][["Normalization"]][["normalized"]]
}


######## INTERNAL - CHECKS FUNCTIONS ###########

#  .checkNA: checks if there are NA/nan in the RflomicsSE assay
#' @title .checkNA
#'
#' @param object An object of class \link{RflomicsSE}
#' @return boolean. if TRUE, NA/nan are detected in the SE::assay.
#' @keywords internal
#' @noRd
#'
.checkNA <- function(object) {
  NA_detect <- ifelse(any(is.na(assay(object))), TRUE, FALSE)
  return(NA_detect)
}

######## INTERNAL

#' @title .tmmNormalization
#' Interface to the calcNormFactors function of the edgeR package  with the 
#' choosen TMM parameters as the normalization method
#' @param object rflomicsSE object
#' @return a data.frame with a row for each sample and columns group, lib.size 
#' and norm.factors containing the group labels, library sizes and normalization 
#' factors. Other columns can be optionally added to give more detailed sample 
#' information.
#' @keywords internal
#' @importFrom edgeR DGEList calcNormFactors
#' @noRd

.tmmNormalization <- function(object){
  
  groups <- getDesignMat(object)
  counts <- assay(object)
  
  dge <- edgeR::DGEList(counts=counts, group=groups$groups)
  dge <- edgeR::calcNormFactors(dge,method="TMM")
  nf  <- dge$samples
  return(nf)
}


#' @title .medianNormalization
#' Interface to calculate the median normalization coefficient 
#' @param object rflomicsSE object
#' @return a data.frame with a row for each sample and columns group, lib.size 
#' and norm.factors containing the group labels, library sizes and normalization 
#' factors. Other columns can be optionally added to give more detailed sample 
#' information.
#' @keywords internal
#' @importFrom stats median
#' @noRd

.medianNormalization <- function(object){
  
  coef <- 
    apply(assay(object), 2, FUN = function(sample_vect) {median(sample_vect)})
  
  return(coef)
}

#' @title .totalSumNormalization
#' Interface to calculate the totalSum normalization coefficient 
#' @param object rflomicsSE object
#' @return a data.frame with a row for each sample and columns group, lib.size 
#' and norm.factors containing the group labels, library sizes and normalization 
#' factors. Other columns can be optionally added to give more detailed sample 
#' information.
#' @keywords internal
#' @noRd

.totalSumNormalization <- function(object){
  
  coef <- 
    apply(assay(object), 2, FUN = function(sample_vect) {sum(sample_vect^2)})
  
  return(coef)
}

#' @title .updateColData
#' @param object rflomicsSE object
#' @return object rflomicsSE object
#' @keywords internal
#' @noRd
.updateColData <- function(object){
  
  colData.df <- colData(object)
  
  for (factor in c(getBioFactors(object), getBatchFactors(object))){
    
    # if only one category remains after the filter, it's will be removed
    if (length(unique(colData.df[[factor]])) <= 1 ) {
      colData.df[[factor]] <- NULL
      factor.types <- getFactorTypes(object)
      metadata(object)$design$factorType <- 
        factor.types[which(names(factor.types) != factor)]
      # replace with setFactorTypes
    }
    else{
      F.levels <- levels(colData.df[[factor]])
      colData.df[[factor]] <- 
        factor(colData.df[[factor]], 
               levels = intersect(F.levels, unique(colData.df[[factor]])))
    }
  }
  colData <- as.data.frame(colData.df)
  order_levels <- 
    with(colData, 
         do.call(order, 
                 colData[c(getBioFactors(object), getBatchFactors(object))]))
  object$samples <- 
    factor(object$samples, levels = unique(object$samples[order_levels]))
  object$groups  <- 
    factor(object$groups, levels = unique(object$groups[order_levels]))
  
  return(object)
}
